## Основные функции сложности 
---
---
`Константная сложность О(1)`
Сложность алгоритма не зависит от входных данных.
Пример – целочисленное деление.
```javascript
function div(a, b) {
    return (a - (a % b)) / b;
}
```
Вне зависимости от значений a и b объем работы не меняется.

---

`Логарифмическая сложность О(log(n))`
**Сложность** растёт логарифмически – на каждом шаге мы уменьшаем количество обрабатываемых данных в несколько раз. В информатике часто работают с логарифмами по основанию два. Значит, что уменьшают объём данных вдвое. Но на сложность алгоритма основание не влияет.

**Пример** – бинарный поиск индекса элемента по отсортированному массиву.([0,1,2,3,4,5...]) 
Суть в том, что на каждом шаге мы берем элемент из середины отсортированного массива и проверяем, равен ли он искомому. Если он больше, продолжаем искать в левой части. Если меньше – в правой. И так до тех пор, пока не найдём. 

```javascript
function binarySearch(sortedNumbers, n) {
    // Определяем точки начала и конца поиска
  let start = 0;
  let end = sortedNumbers.length;
    
  while (start < end) {
        // Находим элемент в середине массива
    const middle = Math.floor((start + end) / 2);
    const value = sortedNumbers[middle];
    
        // Сравниваем аргумент со значением в середине массива
    if (n == value) {
      return middle;
    }

        // Если аргумент меньше, чем серединное значение, разделяем массив пополам
        // Теперь конец массива — это его бывшая середина
    if (n < value) {
      end = middle;
        // Иначе началом массива становится элемент, идущий сразу за «серединой»
    } else {
      start = middle + 1;
    }
  }
  
  // если искомое число не найдено, возвращаем -1
  return -1;
} 
```
Таким образом, для массива размера 1024 понадобится максимум log2(1024) = 10 шагов.И число шагов будет расти очень медленно по сравнению с ростом размера массива. Например, чтобы найти число в отсортированном массиве размером в 1000 раз больше, понадобится всего в 2 раза больше шагов log2(1024000) = 19.96.


`Линейная сложность О(n)`
Сложность растёт прямо пропорционально росту данных.

**Пример** – нахождение минимума/максимума в несортированном массиве. Например: [4,2,100,43,12,1343,12,1]
```javascript
function minMax(numbers) {
// Присваиваем переменным min и max первый элемент массива
  let min = numbers[0];
  let max = numbers[0];
 
  for (let i = 1; i < numbers.length; i++) {
    const n = numbers[i];
// Сравниваем элемент с min
    if (n< min) {
      min = n;
    }
// Сравниваем элемент с max
    if (n > max) {
      max = n;
    }
  }
// Возвращаем найденную пару значений 
  return {min, max};
}
```
**Вывод:** Количество операций линейно зависит от длины массива. Если массив увеличится вдвое, то и количество операций увеличится вдвое. Это и есть линейная зависимость.

`Линейно логарифмическая сложность О(n*log(n))`

